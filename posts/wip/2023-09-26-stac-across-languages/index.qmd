---
title: "STAC across Languages"
description: |
  On-demand data cubes with the STAC API for R and Python.
date: 2023-09-26
# image: figs/poster_thumbnail-min.PNG
categories:
  - r-spatial
  - python
  - rstats
draft: true
---
```{r}
#| label: setup
#| include: false
knitr::opts_chunk$set(message = F, warning = F, echo = T)
```

::: {.panel-tabset group="language"}

## Python

```{python}
import geogif # render gifs from raster images
import geopandas as gpd # handle geospatial data frames
from IPython.display import Image # visualize URLs
import pandas as pd # data wrangling
import pystac_client # connecting to the STAC API
from rasterio.enums import Resampling # perform resampling operations
import rioxarray # handle spatio-temporal arrays
import shapely # create vector objects
import stackstac # build an on-demand STAC data cube
```

## R

```{r}
library(dplyr) # data wrangling
library(gdalcubes) # on-demand data cubes
library(ggplot2) # plotting
library(here) # resolve relative paths
library(knitr) # visualize URLs
library(osmdata) # retrieving OSM data, AOI bounding box
library(rstac) # connecting to the STAC API
library(sf) # handle geospatial data frames
library(stars) # handle spatio-temporal arrays
library(tmap) # visualization
```

:::

::: {.panel-tabset group="language"}

## Python

```{python}
api_url = 'https://earth-search.aws.element84.com/v1'
client = pystac_client.Client.open(api_url)
for collection in client.get_collections():
    print(collection)
```

## R

```{r}
api_url = "https://earth-search.aws.element84.com/v1"
client = stac(api_url)
collections(client) |> get_request()
```

:::

::: {.panel-tabset group="language"}

## Python

```{python}
# collection ID
collection = 'sentinel-2-l2a'
# coordinates
lon = 16.9
lat = 52.4
point = shapely.Point(lon, lat)
# date range
time_extent = '2022-05-01/2022-10-01'
```

## R

```{r}
# collection ID
collection = 'sentinel-2-l2a'
# coordinates
lon = 16.9
lat = 52.4
point = st_point(c(lon, lat))
# date range
time_extent = c("2022-05-01", "2022-10-01")
```

:::


::: {.panel-tabset group="language"}

## Python

```{python}
search = client.search(
    collections=[collection],
    intersects=point,
    datetime=time_extent,
    query=["eo:cloud_cover<10"],
)
items = search.item_collection()
len(items)
```

## R

```{r}
items = client  |> 
  stac_search(
      collections = collection,
      intersects = point, 
      datetime = paste0(time_extent,"T00:00:00Z", collapse = "/"),
      limit = 100
    ) |> 
  post_request() |> 
  items_filter(
    filter_fn = function(x) {x$properties$`eo:cloud_cover` < 10}
  )
items_length(items)
```
:::

To explore the items as data frames we can either convert to a geopandas table or to an sf table. 

::: {.panel-tabset group="language"}

## Python

```{python}
items_df = gpd.GeoDataFrame.from_features(items.to_dict(), crs="epsg:4326")
items_df
```

## R

```{r}
# we add an extra column to be able to subset the original item list
items_df = items_as_sf(items) |> 
  mutate(fid = row_number())
# wrap function around st_as_sf and as_tibble just for nicer printing
st_as_sf(as_tibble(items_df))
```
:::

::: {.panel-tabset group="language"}

## Python

```{python}
ids = items_df.loc[
  (items_df['eo:cloud_cover'] <= 2) &
  (items_df['s2:nodata_pixel_percentage'] <= 10)
]
item = items[ids.index[0]]
item.datetime
```

## R

```{r}
ids = items_df |> 
  filter(
    `eo:cloud_cover` <= 2, `s2:nodata_pixel_percentage` <= 10
  ) |> 
  pull(fid)
item = items$features[[ids[1]]]
item$properties$datetime
```
:::

::: {.panel-tabset group="language"}

## Python

```{python}
thumbnail = item.assets["thumbnail"].href
Image(url = thumbnail)
```

## R

```{r}
item |> 
  assets_url(asset_names = "thumbnail") |> 
  include_graphics()
```
:::
